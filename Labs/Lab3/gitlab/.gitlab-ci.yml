stages:
  - build
  - test
  - analyze
  - quality-gate
  - deploy

variables:
  PIP_CACHE_DIR: "$CI_PROJECT_DIR/.cache/pip"
  PYTHON_VERSION: "3.11"

cache:
  key: ${CI_COMMIT_REF_SLUG}
  paths:
    - .cache/pip
    - .venv/

# ==========================================
# BUILD STAGE
# ==========================================

build:
  stage: build
  image: python:${PYTHON_VERSION}
  script:
    - echo "Setting up Python environment..."
    - python --version
    - pip --version

    # Create virtual environment
    - python -m venv .venv
    - source .venv/bin/activate

    # Upgrade pip
    - pip install --upgrade pip

    # Install dependencies
    - pip install -r requirements.txt
    - pip install -r requirements-dev.txt

    # Verify installation
    - pip list
  artifacts:
    paths:
      - .venv/
    expire_in: 1 hour
  tags:
    - docker

# ==========================================
# TEST STAGE
# ==========================================

lint:
  stage: test
  image: python:${PYTHON_VERSION}
  script:
    - echo "Running code linting..."
    - source .venv/bin/activate

    # Run flake8 for code style
    - flake8 src/ --max-line-length=120 --statistics --count

    # Run pylint for code quality
    - pylint src/ --exit-zero --output-format=text --reports=y | tee pylint-report.txt

    # Run bandit for security issues
    - bandit -r src/ -f json -o bandit-report.json || true
  artifacts:
    paths:
      - pylint-report.txt
      - bandit-report.json
    when: always
    expire_in: 1 week
  dependencies:
    - build
  allow_failure: true
  tags:
    - docker

test:
  stage: test
  image: python:${PYTHON_VERSION}
  script:
    - echo "Running unit tests with coverage..."
    - source .venv/bin/activate

    # Run pytest with coverage
    - pytest tests/ \
        --verbose \
        --cov=src \
        --cov-report=xml:coverage.xml \
        --cov-report=html:htmlcov \
        --cov-report=term-missing \
        --junitxml=junit.xml

    # Display coverage summary
    - coverage report
  coverage: '/(?i)total.*? (100(?:\.0+)?\%|[1-9]?\d(?:\.\d+)?\%)$/'
  artifacts:
    reports:
      junit: junit.xml
      coverage_report:
        coverage_format: cobertura
        path: coverage.xml
    paths:
      - coverage.xml
      - htmlcov/
      - junit.xml
    when: always
    expire_in: 1 week
  dependencies:
    - build
  tags:
    - docker

# ==========================================
# SONARQUBE ANALYSIS STAGE
# ==========================================

sonarqube-analysis:
  stage: analyze
  image:
    name: sonarsource/sonar-scanner-cli:latest
    entrypoint: [""]
  variables:
    SONAR_USER_HOME: "${CI_PROJECT_DIR}/.sonar"
    GIT_DEPTH: "0"  # Tells git to fetch all the commits
  cache:
    key: "${CI_JOB_NAME}"
    paths:
      - .sonar/cache
  script:
    - echo "Running SonarQube analysis..."

    # Display SonarQube configuration
    - echo "Project Key:${CI_PROJECT_NAME}"
    - echo "SonarQube URL:${SONAR_HOST_URL}"

    # Run SonarQube scanner
    - sonar-scanner
      -Dsonar.projectKey=${CI_PROJECT_NAME}
      -Dsonar.projectName="${CI_PROJECT_TITLE}"
      -Dsonar.sources=src
      -Dsonar.tests=tests
      -Dsonar.host.url=${SONAR_HOST_URL}
      -Dsonar.login=${SONAR_TOKEN}
      -Dsonar.python.version=${PYTHON_VERSION}
      -Dsonar.python.coverage.reportPaths=coverage.xml
      -Dsonar.python.xunit.reportPath=junit.xml
      -Dsonar.qualitygate.wait=false
      -Dsonar.scm.provider=git
      -Dsonar.sourceEncoding=UTF-8
  dependencies:
    - test
  allow_failure: false
  only:
    - branches
  tags:
    - docker

# ==========================================
# QUALITY GATE STAGE
# ==========================================

quality-gate:
  stage: quality-gate
  image: curlimages/curl:latest
  script:
    - echo "Checking Quality Gate status..."

    # Wait for SonarQube to process the analysis
    - sleep 10

    # Fetch Quality Gate status
    - |
      QUALITY_GATE_STATUS=$(curl -s -u ${SONAR_TOKEN}: \
        "${SONAR_HOST_URL}/api/qualitygates/project_status?projectKey=${CI_PROJECT_NAME}" \
        | grep -oP '"status":"\K[^"]+' || echo "ERROR")

    # Display result
    - echo "Quality Gate Status:${QUALITY_GATE_STATUS}"

    # Check if passed
    - |
      if [ "${QUALITY_GATE_STATUS}" = "OK" ]; then
        echo "✓ Quality Gate passed!"
        echo "View details at: ${SONAR_HOST_URL}/dashboard?id=${CI_PROJECT_NAME}"
        exit 0
      elif [ "${QUALITY_GATE_STATUS}" = "ERROR" ]; then
        echo "⚠ Could not retrieve Quality Gate status"
        echo "Check SonarQube server at: ${SONAR_HOST_URL}"
        exit 0  # Don't fail if we can't get status
      else
        echo "✗ Quality Gate failed!"
        echo "Issues found. Check details at: ${SONAR_HOST_URL}/dashboard?id=${CI_PROJECT_NAME}"
        exit 1
      fi
  dependencies: []
  only:
    - branches
  tags:
    - docker

# ==========================================
# DEPLOY STAGE
# ==========================================

build-docker:
  stage: deploy
  image: docker:20.10.16
  services:
    - docker:20.10.16-dind
  before_script:
    - docker login -u $CI_REGISTRY_USER -p $CI_REGISTRY_PASSWORD $CI_REGISTRY
  script:
    - echo "Building Docker image..."
    - docker build -t $CI_REGISTRY_IMAGE:$CI_COMMIT_SHORT_SHA .
    - docker tag $CI_REGISTRY_IMAGE:$CI_COMMIT_SHORT_SHA $CI_REGISTRY_IMAGE:latest

    - echo "Pushing Docker image..."
    - docker push $CI_REGISTRY_IMAGE:$CI_COMMIT_SHORT_SHA
    - docker push $CI_REGISTRY_IMAGE:latest
  dependencies:
    - quality-gate
  only:
    - main
    - develop
  tags:
    - docker

deploy-staging:
  stage: deploy
  image: google/cloud-sdk:alpine
  script:
    - echo "Deploying to staging environment..."

    # Authenticate with GCP
    - echo ${GCP_SERVICE_KEY} | base64 -d > ${HOME}/gcloud-service-key.json
    - gcloud auth activate-service-account --key-file ${HOME}/gcloud-service-key.json
    - gcloud config set project ${GCP_PROJECT_ID}

    # Deploy to Cloud Run
    - |
      gcloud run deploy ${CI_PROJECT_NAME}-staging \
        --image $CI_REGISTRY_IMAGE:$CI_COMMIT_SHORT_SHA \
        --platform managed \
        --region europe-west1 \
        --allow-unauthenticated \
        --memory 512Mi \
        --set-env-vars "ENVIRONMENT=staging"

    # Get service URL
    - |
      SERVICE_URL=$(gcloud run services describe ${CI_PROJECT_NAME}-staging \
        --region europe-west1 \
        --format 'value(status.url)')
      echo "Application deployed to: ${SERVICE_URL}"
  environment:
    name: staging
    url: https://${CI_PROJECT_NAME}-staging-xxxxx.run.app
  dependencies:
    - quality-gate
  only:
    - develop
  tags:
    - docker

deploy-production:
  stage: deploy
  image: google/cloud-sdk:alpine
  script:
    - echo "Deploying to production environment..."

    # Authenticate with GCP
    - echo ${GCP_SERVICE_KEY} | base64 -d > ${HOME}/gcloud-service-key.json
    - gcloud auth activate-service-account --key-file ${HOME}/gcloud-service-key.json
    - gcloud config set project ${GCP_PROJECT_ID}

    # Deploy to Cloud Run
    - |
      gcloud run deploy ${CI_PROJECT_NAME} \
        --image $CI_REGISTRY_IMAGE:$CI_COMMIT_SHORT_SHA \
        --platform managed \
        --region europe-west1 \
        --allow-unauthenticated \
        --memory 1Gi \
        --min-instances 1 \
        --max-instances 10 \
        --set-env-vars "ENVIRONMENT=production"

    # Get service URL
    - |
      SERVICE_URL=$(gcloud run services describe ${CI_PROJECT_NAME} \
        --region europe-west1 \
        --format 'value(status.url)')
      echo "Application deployed to: ${SERVICE_URL}"
  environment:
    name: production
    url: https://${CI_PROJECT_NAME}-xxxxx.run.app
  dependencies:
    - quality-gate
  when: manual
  only:
    - main
    - master
  tags:
    - docker

# ==========================================
# SECURITY SCAN
# ==========================================

security-scan:
  stage: test
  image: python:${PYTHON_VERSION}
  script:
    - echo "Running security vulnerability scan..."
    - source .venv/bin/activate

    # Scan for known vulnerabilities in dependencies
    - pip install safety
    - safety check --json --output safety-report.json || true

    # Display results
    - safety check || true
  artifacts:
    paths:
      - safety-report.json
    when: always
    expire_in: 1 week
  dependencies:
    - build
  allow_failure: true
  tags:
    - docker

# ==========================================
# NOTIFICATION
# ==========================================

notify-success:
  stage: .post
  image: curlimages/curl:latest
  script:
    - echo "✓ Pipeline completed successfully for ${CI_PROJECT_NAME}!"
    - echo "Branch:${CI_COMMIT_REF_NAME}"
    - echo "Commit:${CI_COMMIT_SHORT_SHA}"
    - echo "SonarQube: ${SONAR_HOST_URL}/dashboard?id=${CI_PROJECT_NAME}"
  when: on_success
  only:
    - main
    - develop

notify-failure:
  stage: .post
  image: curlimages/curl:latest
  script:
    - echo "✗ Pipeline failed for ${CI_PROJECT_NAME}!"
    - echo "Branch:${CI_COMMIT_REF_NAME}"
    - echo "Commit:${CI_COMMIT_SHORT_SHA}"
    - echo "Check logs at:${CI_PIPELINE_URL}"
  when: on_failure
  only:
    - main
    - develop
